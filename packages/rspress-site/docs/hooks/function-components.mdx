# Hook ä¸å‡½æ•°ç»„ä»¶

## æ¦‚è¿°

Hook ä¸å‡½æ•°ç»„ä»¶çš„ç»“åˆæ˜¯ React ç°ä»£å¼€å‘çš„æ ¸å¿ƒæ¨¡å¼ã€‚ç†è§£ Hook å¦‚ä½•åœ¨å‡½æ•°ç»„ä»¶ä¸­å·¥ä½œï¼Œä»¥åŠå®ƒä»¬ä¹‹é—´çš„æ·±å±‚å…³ç³»ï¼Œæ˜¯æŒæ¡ React çŠ¶æ€ç®¡ç†çš„å…³é”®ã€‚æœ¬ç« é€šè¿‡å¯æ‰§è¡Œæ¡ˆä¾‹æ·±å…¥æ¢è®¨è¿™ç§å…³ç³»çš„å®ç°æœºåˆ¶ï¼Œè§£æ React è®¾è®¡ç†å¿µï¼Œå¹¶ä¸ Vue 3 Composition API è¿›è¡Œå¯¹æ¯”åˆ†æã€‚

## å¯æ‰§è¡Œæ¡ˆä¾‹ï¼šå‡½æ•°ç»„ä»¶æ¼”è¿›å†ç¨‹

### æ¡ˆä¾‹ 1ï¼šçŠ¶æ€ç®¡ç†èƒ½åŠ›çš„æ¼”è¿›

è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªçœŸå®çš„ç”¨æˆ·ä¿¡æ¯ç®¡ç†ç»„ä»¶æ¥ç†è§£ Hook å¸¦æ¥çš„å˜é©ï¼š

#### ä¼ ç»Ÿç±»ç»„ä»¶å®ç°

```javascript
// åœ¨ packages/react-dojo/dojo/index.jsx ä¸­å¯¹æ¯”è¿™ä¸¤ç§å®ç°

// React 16.8 ä¹‹å‰ï¼šå¿…é¡»ä½¿ç”¨ç±»ç»„ä»¶æ¥ç®¡ç†çŠ¶æ€
class UserProfileClass extends React.Component {
  constructor(props) {
    super(props);
    // ğŸ’” æ‰€æœ‰çŠ¶æ€é›†ä¸­åœ¨ä¸€ä¸ªå¯¹è±¡ä¸­
    this.state = {
      user: null,
      loading: true,
      error: null,
      isEditing: false,
      formData: { name: '', email: '' },
      validationErrors: {}
    };
    
    // ğŸ’” éœ€è¦æ‰‹åŠ¨ç»‘å®šæ–¹æ³•
    this.handleEdit = this.handleEdit.bind(this);
    this.handleSave = this.handleSave.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.validateForm = this.validateForm.bind(this);
  }
  
  // ğŸ’” ç”Ÿå‘½å‘¨æœŸæ–¹æ³•åˆ†æ•£ï¼Œç›¸å…³é€»è¾‘è¢«æ‹†åˆ†
  componentDidMount() {
    this.fetchUser();
    document.title = `ç”¨æˆ·èµ„æ–™ - ${this.props.userId}`;
    
    // ç›‘å¬çª—å£å¤§å°å˜åŒ–
    window.addEventListener('resize', this.handleResize);
  }
  
  componentDidUpdate(prevProps, prevState) {
    if (prevProps.userId !== this.props.userId) {
      this.fetchUser();
    }
    
    if (prevState.user !== this.state.user && this.state.user) {
      document.title = `ç”¨æˆ·èµ„æ–™ - ${this.state.user.name}`;
    }
  }
  
  componentWillUnmount() {
    // ğŸ’” æ¸…ç†é€»è¾‘è¿œç¦»è®¾ç½®é€»è¾‘
    window.removeEventListener('resize', this.handleResize);
  }
  
  // ğŸ’” å¤æ‚çš„çŠ¶æ€æ›´æ–°é€»è¾‘
  fetchUser = async () => {
    try {
      this.setState({ loading: true, error: null });
      const response = await fetch(`/api/users/${this.props.userId}`);
      
      if (!response.ok) {
        throw new Error('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥');
      }
      
      const user = await response.json();
      this.setState({ 
        user, 
        loading: false,
        formData: { name: user.name, email: user.email }
      });
    } catch (error) {
      this.setState({ error: error.message, loading: false });
    }
  };
  
  handleEdit() {
    this.setState({ isEditing: true });
  }
  
  handleSave = async () => {
    const errors = this.validateForm();
    if (Object.keys(errors).length > 0) {
      this.setState({ validationErrors: errors });
      return;
    }
    
    try {
      const response = await fetch(`/api/users/${this.props.userId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(this.state.formData)
      });
      
      if (!response.ok) throw new Error('ä¿å­˜å¤±è´¥');
      
      const updatedUser = await response.json();
      this.setState({
        user: updatedUser,
        isEditing: false,
        validationErrors: {}
      });
    } catch (error) {
      this.setState({ error: error.message });
    }
  };
  
  handleCancel() {
    this.setState({
      isEditing: false,
      formData: { 
        name: this.state.user.name, 
        email: this.state.user.email 
      },
      validationErrors: {}
    });
  }
  
  validateForm() {
    const errors = {};
    const { name, email } = this.state.formData;
    
    if (!name.trim()) errors.name = 'å§“åä¸èƒ½ä¸ºç©º';
    if (!email.trim()) errors.email = 'é‚®ç®±ä¸èƒ½ä¸ºç©º';
    else if (!/\S+@\S+\.\S+/.test(email)) errors.email = 'é‚®ç®±æ ¼å¼æ— æ•ˆ';
    
    return errors;
  }
  
  render() {
    const { user, loading, error, isEditing, formData, validationErrors } = this.state;
    
    if (loading) return <div className="loading">åŠ è½½ä¸­...</div>;
    if (error) return <div className="error">é”™è¯¯: {error}</div>;
    if (!user) return <div>ç”¨æˆ·ä¸å­˜åœ¨</div>;
    
    return (
      <div className="user-profile">
        <h2>ç”¨æˆ·èµ„æ–™</h2>
        {isEditing ? (
          <form onSubmit={(e) => { e.preventDefault(); this.handleSave(); }}>
            <div>
              <label>å§“å:</label>
              <input
                type="text"
                value={formData.name}
                onChange={(e) => this.setState({
                  formData: { ...formData, name: e.target.value }
                })}
              />
              {validationErrors.name && <span className="error">{validationErrors.name}</span>}
            </div>
            <div>
              <label>é‚®ç®±:</label>
              <input
                type="email"
                value={formData.email}
                onChange={(e) => this.setState({
                  formData: { ...formData, email: e.target.value }
                })}
              />
              {validationErrors.email && <span className="error">{validationErrors.email}</span>}
            </div>
            <button type="submit">ä¿å­˜</button>
            <button type="button" onClick={this.handleCancel}>å–æ¶ˆ</button>
          </form>
        ) : (
          <div>
            <p>å§“å: {user.name}</p>
            <p>é‚®ç®±: {user.email}</p>
            <button onClick={this.handleEdit}>ç¼–è¾‘</button>
          </div>
        )}
      </div>
    );
  }
}
```

#### ç°ä»£ Hook å®ç°

```javascript
// React 16.8+ çš„å‡½æ•°ç»„ä»¶ï¼šä½¿ç”¨ Hook å®ç°ç›¸åŒåŠŸèƒ½

// è‡ªå®šä¹‰ Hookï¼šæ•°æ®è·å–é€»è¾‘
function useUserData(userId) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  const fetchUser = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥');
      
      const userData = await response.json();
      setUser(userData);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [userId]);
  
  useEffect(() => {
    fetchUser();
  }, [fetchUser]);
  
  return { user, loading, error, refetch: fetchUser };
}

// è‡ªå®šä¹‰ Hookï¼šè¡¨å•é€»è¾‘
function useFormValidation(initialData, validationRules) {
  const [formData, setFormData] = useState(initialData);
  const [errors, setErrors] = useState({});
  
  const updateField = useCallback((field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    // æ¸…é™¤è¯¥å­—æ®µçš„é”™è¯¯
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: '' }));
    }
  }, [errors]);
  
  const validate = useCallback(() => {
    const newErrors = {};
    
    Object.entries(validationRules).forEach(([field, rules]) => {
      const value = formData[field];
      
      if (rules.required && !value?.trim()) {
        newErrors[field] = `${rules.label}ä¸èƒ½ä¸ºç©º`;
      } else if (rules.pattern && value && !rules.pattern.test(value)) {
        newErrors[field] = rules.message || `${rules.label}æ ¼å¼æ— æ•ˆ`;
      }
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [formData, validationRules]);
  
  const reset = useCallback(() => {
    setFormData(initialData);
    setErrors({});
  }, [initialData]);
  
  return {
    formData,
    errors,
    updateField,
    validate,
    reset,
    isValid: Object.keys(errors).length === 0
  };
}

// è‡ªå®šä¹‰ Hookï¼šç¼–è¾‘çŠ¶æ€ç®¡ç†
function useEditMode(user) {
  const [isEditing, setIsEditing] = useState(false);
  
  const validationRules = useMemo(() => ({
    name: { required: true, label: 'å§“å' },
    email: {
      required: true,
      label: 'é‚®ç®±',
      pattern: /\S+@\S+\.\S+/,
      message: 'é‚®ç®±æ ¼å¼æ— æ•ˆ'
    }
  }), []);
  
  const formHook = useFormValidation(
    user ? { name: user.name, email: user.email } : { name: '', email: '' },
    validationRules
  );
  
  const startEdit = useCallback(() => {
    setIsEditing(true);
    formHook.reset();
  }, [formHook]);
  
  const cancelEdit = useCallback(() => {
    setIsEditing(false);
    formHook.reset();
  }, [formHook]);
  
  return {
    isEditing,
    setIsEditing,
    startEdit,
    cancelEdit,
    ...formHook
  };
}

// ä¸»ç»„ä»¶ï¼šç»„åˆæ‰€æœ‰ Hook
function UserProfileHooks({ userId }) {
  // âœ… æ•°æ®è·å–é€»è¾‘ç‹¬ç«‹
  const { user, loading, error, refetch } = useUserData(userId);
  
  // âœ… ç¼–è¾‘é€»è¾‘ç‹¬ç«‹
  const editHook = useEditMode(user);
  
  // âœ… å‰¯ä½œç”¨é€»è¾‘èšåˆï¼Œç›¸å…³é€»è¾‘åœ¨ä¸€èµ·
  useEffect(() => {
    if (user) {
      document.title = `ç”¨æˆ·èµ„æ–™ - ${user.name}`;
    }
    
    return () => {
      document.title = 'åº”ç”¨';
    };
  }, [user]);
  
  // âœ… çª—å£å¤§å°ç›‘å¬é€»è¾‘ç‹¬ç«‹
  useEffect(() => {
    const handleResize = () => {
      console.log('çª—å£å¤§å°å˜åŒ–:', window.innerWidth);
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  // âœ… ä¿å­˜é€»è¾‘
  const handleSave = useCallback(async () => {
    if (!editHook.validate()) return;
    
    try {
      const response = await fetch(`/api/users/${userId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(editHook.formData)
      });
      
      if (!response.ok) throw new Error('ä¿å­˜å¤±è´¥');
      
      editHook.setIsEditing(false);
      refetch(); // é‡æ–°è·å–æ•°æ®
    } catch (err) {
      console.error('ä¿å­˜å¤±è´¥:', err.message);
    }
  }, [editHook, userId, refetch]);
  
  if (loading) return <div className="loading">åŠ è½½ä¸­...</div>;
  if (error) return <div className="error">é”™è¯¯: {error}</div>;
  if (!user) return <div>ç”¨æˆ·ä¸å­˜åœ¨</div>;
  
  return (
    <div className="user-profile">
      <h2>ç”¨æˆ·èµ„æ–™</h2>
      {editHook.isEditing ? (
        <form onSubmit={(e) => { e.preventDefault(); handleSave(); }}>
          <div>
            <label>å§“å:</label>
            <input
              type="text"
              value={editHook.formData.name}
              onChange={(e) => editHook.updateField('name', e.target.value)}
            />
            {editHook.errors.name && <span className="error">{editHook.errors.name}</span>}
          </div>
          <div>
            <label>é‚®ç®±:</label>
            <input
              type="email"
              value={editHook.formData.email}
              onChange={(e) => editHook.updateField('email', e.target.value)}
            />
            {editHook.errors.email && <span className="error">{editHook.errors.email}</span>}
          </div>
          <button type="submit">ä¿å­˜</button>
          <button type="button" onClick={editHook.cancelEdit}>å–æ¶ˆ</button>
        </form>
      ) : (
        <div>
          <p>å§“å: {user.name}</p>
          <p>é‚®ç®±: {user.email}</p>
          <button onClick={editHook.startEdit}>ç¼–è¾‘</button>
        </div>
      )}
    </div>
  );
}
```

### ä¸ Vue 3 Composition API å¯¹æ¯”

```javascript
// Vue 3 Composition API å®ç°
<template>
  <div class="user-profile">
    <h2>ç”¨æˆ·èµ„æ–™</h2>
    <div v-if="loading" class="loading">åŠ è½½ä¸­...</div>
    <div v-else-if="error" class="error">é”™è¯¯: {{ error }}</div>
    <div v-else-if="!user">ç”¨æˆ·ä¸å­˜åœ¨</div>
    <form v-else-if="isEditing" @submit.prevent="handleSave">
      <div>
        <label>å§“å:</label>
        <input v-model="formData.name" type="text" />
        <span v-if="errors.name" class="error">{{ errors.name }}</span>
      </div>
      <div>
        <label>é‚®ç®±:</label>
        <input v-model="formData.email" type="email" />
        <span v-if="errors.email" class="error">{{ errors.email }}</span>
      </div>
      <button type="submit">ä¿å­˜</button>
      <button type="button" @click="cancelEdit">å–æ¶ˆ</button>
    </form>
    <div v-else>
      <p>å§“å: {{ user.name }}</p>
      <p>é‚®ç®±: {{ user.email }}</p>
      <button @click="startEdit">ç¼–è¾‘</button>
    </div>
  </div>
</template>

<script>
import { ref, reactive, computed, watch, onMounted, onUnmounted } from 'vue'

// Vue 3 ç»„åˆå¼å‡½æ•°ï¼ˆç±»ä¼¼ React Hookï¼‰
function useUserData(userId) {
  const user = ref(null)
  const loading = ref(true)
  const error = ref(null)
  
  const fetchUser = async () => {
    try {
      loading.value = true
      error.value = null
      
      const response = await fetch(`/api/users/${userId.value}`)
      if (!response.ok) throw new Error('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥')
      
      user.value = await response.json()
    } catch (err) {
      error.value = err.message
    } finally {
      loading.value = false
    }
  }
  
  // Vue çš„ watch ç±»ä¼¼ React çš„ useEffect
  watch(userId, fetchUser, { immediate: true })
  
  return { user, loading, error, refetch: fetchUser }
}

function useEditMode(user) {
  const isEditing = ref(false)
  const formData = reactive({ name: '', email: '' })
  const errors = reactive({})
  
  const validate = () => {
    Object.keys(errors).forEach(key => delete errors[key])
    
    if (!formData.name.trim()) errors.name = 'å§“åä¸èƒ½ä¸ºç©º'
    if (!formData.email.trim()) errors.email = 'é‚®ç®±ä¸èƒ½ä¸ºç©º'
    else if (!/\S+@\S+\.\S+/.test(formData.email)) errors.email = 'é‚®ç®±æ ¼å¼æ— æ•ˆ'
    
    return Object.keys(errors).length === 0
  }
  
  const startEdit = () => {
    isEditing.value = true
    if (user.value) {
      formData.name = user.value.name
      formData.email = user.value.email
    }
  }
  
  const cancelEdit = () => {
    isEditing.value = false
    Object.keys(errors).forEach(key => delete errors[key])
  }
  
  return {
    isEditing,
    formData,
    errors,
    validate,
    startEdit,
    cancelEdit
  }
}

export default {
  props: ['userId'],
  setup(props) {
    const { user, loading, error, refetch } = useUserData(toRef(props, 'userId'))
    const editHook = useEditMode(user)
    
    // ç±»ä¼¼ useEffect
    watch(user, (newUser) => {
      if (newUser) {
        document.title = `ç”¨æˆ·èµ„æ–™ - ${newUser.name}`
      }
    })
    
    onMounted(() => {
      const handleResize = () => {
        console.log('çª—å£å¤§å°å˜åŒ–:', window.innerWidth)
      }
      window.addEventListener('resize', handleResize)
      
      onUnmounted(() => {
        window.removeEventListener('resize', handleResize)
        document.title = 'åº”ç”¨'
      })
    })
    
    const handleSave = async () => {
      if (!editHook.validate()) return
      
      try {
        const response = await fetch(`/api/users/${props.userId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(editHook.formData)
        })
        
        if (!response.ok) throw new Error('ä¿å­˜å¤±è´¥')
        
        editHook.isEditing.value = false
        refetch()
      } catch (err) {
        console.error('ä¿å­˜å¤±è´¥:', err.message)
      }
    }
    
    return {
      user,
      loading,
      error,
      ...editHook,
      handleSave
    }
  }
}
</script>
```

## Hook å·¥ä½œæµç¨‹æ·±åº¦è§£æ

### å®Œæ•´çš„ Hook æ‰§è¡Œæµç¨‹

```mermaid
flowchart TD
    A[ç»„ä»¶å‡½æ•°è°ƒç”¨] --> B[è®¾ç½® Hook æ‰§è¡Œç¯å¢ƒ]
    B --> C[é€‰æ‹©åˆé€‚çš„ Dispatcher]
    C --> D{æ˜¯å¦ä¸ºé¦–æ¬¡æ¸²æŸ“?}
    
    D -->|æ˜¯| E[æŒ‚è½½é˜¶æ®µ Dispatcher]
    D -->|å¦| F[æ›´æ–°é˜¶æ®µ Dispatcher]
    
    E --> G[mountWorkInProgressHook]
    F --> H[updateWorkInProgressHook]
    
    G --> I[åˆ›å»ºæ–° Hook å¯¹è±¡]
    H --> J[å¤ç”¨ç°æœ‰ Hook å¯¹è±¡]
    
    I --> K[åˆå§‹åŒ– Hook çŠ¶æ€]
    J --> L[æ›´æ–° Hook çŠ¶æ€]
    
    K --> M[æ„å»º Hook é“¾è¡¨]
    L --> M
    
    M --> N[å¤„ç†å‰¯ä½œç”¨]
    N --> O[è¿”å› JSX]
    O --> P[æ¸…ç†æ‰§è¡Œç¯å¢ƒ]
```

### æ¡ˆä¾‹ 2ï¼šHook æ‰§è¡Œæµç¨‹è¿½è¸ª

è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªå®é™…æ¡ˆä¾‹æ¥è¿½è¸ª Hook çš„å®Œæ•´æ‰§è¡Œæµç¨‹ï¼š

```javascript
// åœ¨ packages/react-dojo/dojo/index.jsx ä¸­è¿è¡Œæ­¤æ¡ˆä¾‹

function HookFlowTracker() {
  console.log('ğŸš€ ç»„ä»¶å‡½æ•°å¼€å§‹æ‰§è¡Œ');
  
  // Hook 1: useState
  console.log('ğŸ“ å³å°†è°ƒç”¨ç¬¬ä¸€ä¸ª useState');
  const [count, setCount] = useState(() => {
    console.log('ğŸ”§ useState åˆå§‹åŒ–å‡½æ•°æ‰§è¡Œ');
    return 0;
  });
  console.log('âœ… ç¬¬ä¸€ä¸ª useState å®Œæˆï¼Œå½“å‰å€¼:', count);
  
  // Hook 2: useState
  console.log('ğŸ“ å³å°†è°ƒç”¨ç¬¬äºŒä¸ª useState');
  const [name, setName] = useState('React');
  console.log('âœ… ç¬¬äºŒä¸ª useState å®Œæˆï¼Œå½“å‰å€¼:', name);
  
  // Hook 3: useEffect
  console.log('ğŸ“ å³å°†è°ƒç”¨ç¬¬ä¸€ä¸ª useEffect');
  useEffect(() => {
    console.log('ğŸ¯ useEffect 1 æ‰§è¡Œ - æŒ‚è½½æ—¶');
    return () => {
      console.log('ğŸ§¹ useEffect 1 æ¸…ç†å‡½æ•°');
    };
  }, []);
  console.log('âœ… ç¬¬ä¸€ä¸ª useEffect æ³¨å†Œå®Œæˆ');
  
  // Hook 4: useEffect
  console.log('ğŸ“ å³å°†è°ƒç”¨ç¬¬äºŒä¸ª useEffect');
  useEffect(() => {
    console.log('ğŸ¯ useEffect 2 æ‰§è¡Œ - count å˜åŒ–:', count);
  }, [count]);
  console.log('âœ… ç¬¬äºŒä¸ª useEffect æ³¨å†Œå®Œæˆ');
  
  // Hook 5: useMemo
  console.log('ğŸ“ å³å°†è°ƒç”¨ useMemo');
  const expensiveValue = useMemo(() => {
    console.log('ğŸ§® useMemo è®¡ç®—æ‰§è¡Œï¼Œcount:', count);
    return count * 1000;
  }, [count]);
  console.log('âœ… useMemo å®Œæˆï¼Œè®¡ç®—å€¼:', expensiveValue);
  
  // Hook 6: useCallback
  console.log('ğŸ“ å³å°†è°ƒç”¨ useCallback');
  const handleIncrement = useCallback(() => {
    console.log('ğŸ–±ï¸ handleIncrement è¢«è°ƒç”¨');
    setCount(prev => {
      console.log('ğŸ“Š setCount æ›´æ–°ï¼Œå‰å€¼:', prev, 'æ–°å€¼:', prev + 1);
      return prev + 1;
    });
  }, []);
  console.log('âœ… useCallback å®Œæˆ');
  
  console.log('ğŸ ç»„ä»¶å‡½æ•°æ‰§è¡Œå®Œæˆï¼Œå³å°†è¿”å› JSX');
  
  return (
    <div>
      <h3>Hook æ‰§è¡Œæµç¨‹è¿½è¸ª</h3>
      <p>è®¡æ•°: {count}</p>
      <p>åç§°: {name}</p>
      <p>è®¡ç®—å€¼: {expensiveValue}</p>
      <button onClick={handleIncrement}>å¢åŠ è®¡æ•°</button>
      <button onClick={() => setName(name === 'React' ? 'Vue' : 'React')}>
        åˆ‡æ¢åç§°
      </button>
    </div>
  );
}
```

### React Hook è®¾è®¡ç†å¿µåˆ†æ

**1. å•ä¸€èŒè´£åŸåˆ™**
```javascript
// âœ… React Hook é¼“åŠ±åŠŸèƒ½åˆ†ç¦»
function UserProfile() {
  const userData = useUserData();      // æ•°æ®è·å–
  const editMode = useEditMode();      // ç¼–è¾‘çŠ¶æ€
  const validation = useValidation();  // è¡¨å•éªŒè¯
  const permissions = usePermissions(); // æƒé™æ£€æŸ¥
  
  // æ¯ä¸ª Hook ä¸“æ³¨äºä¸€ä¸ªç‰¹å®šåŠŸèƒ½
}

// å¯¹æ¯” Vue 3ï¼Œæ•°æ®å¯èƒ½æ›´é›†ä¸­
function useUserProfile() {
  const state = reactive({
    user: null,
    isEditing: false,
    formData: {},
    errors: {},
    permissions: []
  });
  
  // æ‰€æœ‰çŠ¶æ€åœ¨ä¸€ä¸ªå“åº”å¼å¯¹è±¡ä¸­
}
```

**2. å‡½æ•°å¼ç¼–ç¨‹æ€æƒ³**
```javascript
// React Hook ä½“ç°å‡½æ•°å¼ç¼–ç¨‹
const Component = () => {
  const [state, setState] = useState(0);
  
  // çŠ¶æ€æ˜¯ä¸å¯å˜çš„ï¼Œé€šè¿‡å‡½æ•°æ›´æ–°
  const increment = () => setState(prev => prev + 1);
  
  return <button onClick={increment}>{state}</button>;
};

// Vue 3 æ›´æ¥è¿‘é¢å‘å¯¹è±¡
const Component = {
  setup() {
    const state = ref(0);
    
    // ç›´æ¥ä¿®æ”¹å“åº”å¼å¼•ç”¨
    const increment = () => state.value++;
    
    return { state, increment };
  }
};
```

**3. æ˜¾å¼ä¾èµ–ç®¡ç†**
```javascript
// React Hook æ˜¾å¼å£°æ˜ä¾èµ–
useEffect(() => {
  // å‰¯ä½œç”¨é€»è¾‘
}, [dep1, dep2]); // æ˜ç¡®æŒ‡å®šä¾èµ–

// Vue 3 è‡ªåŠ¨ä¾èµ–æ”¶é›†
watch(() => {
  // Vue è‡ªåŠ¨è¿½è¸ªå“åº”å¼æ•°æ®çš„ä¾èµ–
  console.log(count.value + name.value);
});
```

## Hook åœ¨å‡½æ•°ç»„ä»¶ä¸­çš„ç”Ÿå‘½å‘¨æœŸ

### ç»„ä»¶æŒ‚è½½é˜¶æ®µ

```mermaid
graph TD
    A[å‡½æ•°ç»„ä»¶è°ƒç”¨] --> B[åˆ›å»º Hook é“¾è¡¨]
    B --> C[åˆå§‹åŒ– Hook çŠ¶æ€]
    C --> D[æ‰§è¡Œå‰¯ä½œç”¨ Hook]
    D --> E[è¿”å› JSX]
    E --> F[Fiber èŠ‚ç‚¹åˆ›å»º]
```

```javascript
function MyComponent() {
  console.log('1. ç»„ä»¶å‡½æ•°å¼€å§‹æ‰§è¡Œ');
  
  // 2. åˆ›å»ºç¬¬ä¸€ä¸ª Hook
  const [count, setCount] = useState(0);
  console.log('2. useState Hook åˆ›å»º');
  
  // 3. åˆ›å»ºç¬¬äºŒä¸ª Hook
  const [name, setName] = useState('');
  console.log('3. ç¬¬äºŒä¸ª useState Hook åˆ›å»º');
  
  // 4. åˆ›å»º effect Hook
  useEffect(() => {
    console.log('5. useEffect å‰¯ä½œç”¨æ‰§è¡Œ');
    return () => {
      console.log('ç»„ä»¶å¸è½½æ—¶çš„æ¸…ç†');
    };
  }, []);
  console.log('4. useEffect Hook åˆ›å»º');
  
  console.log('6. ç»„ä»¶å‡½æ•°æ‰§è¡Œå®Œæˆ');
  return <div>{count} - {name}</div>;
}
```

### ç»„ä»¶æ›´æ–°é˜¶æ®µ

```mermaid
graph TD
    A[çŠ¶æ€æ›´æ–°è§¦å‘] --> B[å‡½æ•°ç»„ä»¶é‡æ–°è°ƒç”¨]
    B --> C[éå†ç°æœ‰ Hook é“¾è¡¨]
    C --> D[æ›´æ–° Hook çŠ¶æ€]
    D --> E[æ‰§è¡Œå‰¯ä½œç”¨ Hook]
    E --> F[è¿”å›æ–° JSX]
```

```javascript
function MyComponent() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('ç»„ä»¶æ›´æ–°ï¼Œcount:', count);
  }, [count]); // ä¾èµ– count
  
  useEffect(() => {
    console.log('æ¯æ¬¡æ¸²æŸ“éƒ½æ‰§è¡Œ');
  }); // æ— ä¾èµ–æ•°ç»„
  
  useEffect(() => {
    console.log('åªåœ¨æŒ‚è½½æ—¶æ‰§è¡Œ');
  }, []); // ç©ºä¾èµ–æ•°ç»„
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        å¢åŠ 
      </button>
    </div>
  );
}
```

### æ¡ˆä¾‹ 3ï¼šHook ç”Ÿå‘½å‘¨æœŸå¯è§†åŒ–

```javascript
// åœ¨ packages/react-dojo/dojo/index.jsx ä¸­ä½“éªŒ Hook ç”Ÿå‘½å‘¨æœŸ

function LifecycleVisualizer({ userId }) {
  const [renderCount, setRenderCount] = useState(0);
  const [data, setData] = useState(null);
  
  // ç»„ä»¶æ¯æ¬¡æ¸²æŸ“æ—¶å¢åŠ è®¡æ•°
  useEffect(() => {
    setRenderCount(prev => prev + 1);
    console.log(`ğŸ”„ ç»„ä»¶ç¬¬ ${renderCount + 1} æ¬¡æ¸²æŸ“`);
  });
  
  // æŒ‚è½½æ—¶çš„å‰¯ä½œç”¨
  useEffect(() => {
    console.log('ğŸ¬ ç»„ä»¶æŒ‚è½½ - ç±»ä¼¼ componentDidMount');
    
    return () => {
      console.log('ğŸ’€ ç»„ä»¶å¸è½½ - ç±»ä¼¼ componentWillUnmount');
    };
  }, []);
  
  // ä¾èµ–å˜åŒ–æ—¶çš„å‰¯ä½œç”¨
  useEffect(() => {
    if (userId) {
      console.log('ğŸ“¡ userId å˜åŒ–ï¼Œé‡æ–°è·å–æ•°æ®:', userId);
      
      // æ¨¡æ‹Ÿæ•°æ®è·å–
      const timer = setTimeout(() => {
        setData({ id: userId, name: `ç”¨æˆ·${userId}` });
      }, 1000);
      
      return () => {
        console.log('ğŸš« æ¸…ç†å‰ä¸€æ¬¡çš„æ•°æ®è·å–');
        clearTimeout(timer);
      };
    }
  }, [userId]);
  
  // æ•°æ®å˜åŒ–æ—¶çš„å‰¯ä½œç”¨
  useEffect(() => {
    if (data) {
      console.log('ğŸ“Š ç”¨æˆ·æ•°æ®æ›´æ–°:', data);
      document.title = `ç”¨æˆ·èµ„æ–™ - ${data.name}`;
    }
  }, [data]);
  
  return (
    <div>
      <h3>Hook ç”Ÿå‘½å‘¨æœŸå¯è§†åŒ–</h3>
      <p>æ¸²æŸ“æ¬¡æ•°: {renderCount}</p>
      <p>ç”¨æˆ·ID: {userId}</p>
      <p>ç”¨æˆ·æ•°æ®: {data ? JSON.stringify(data) : 'åŠ è½½ä¸­...'}</p>
    </div>
  );
}

// çˆ¶ç»„ä»¶ç”¨äºæµ‹è¯•ç”Ÿå‘½å‘¨æœŸ
function LifecycleTester() {
  const [userId, setUserId] = useState(1);
  const [showComponent, setShowComponent] = useState(true);
  
  return (
    <div>
      <h2>Hook ç”Ÿå‘½å‘¨æœŸæµ‹è¯•</h2>
      <button onClick={() => setUserId(prev => prev + 1)}>
        åˆ‡æ¢ç”¨æˆ· (å½“å‰: {userId})
      </button>
      <button onClick={() => setShowComponent(prev => !prev)}>
        {showComponent ? 'å¸è½½' : 'æŒ‚è½½'}ç»„ä»¶
      </button>
      
      {showComponent && <LifecycleVisualizer userId={userId} />}
    </div>
  );
}
```

## Hook çŠ¶æ€çš„å­˜å‚¨æœºåˆ¶

### Fiber èŠ‚ç‚¹ä¸­çš„ Hook å­˜å‚¨

æ¯ä¸ªå‡½æ•°ç»„ä»¶å¯¹åº”ä¸€ä¸ª Fiber èŠ‚ç‚¹ï¼ŒHook é“¾è¡¨å­˜å‚¨åœ¨ Fiber èŠ‚ç‚¹çš„ `memoizedState` å±æ€§ä¸­ï¼š

```javascript
// Fiber èŠ‚ç‚¹ç»“æ„ï¼ˆç®€åŒ–ï¼‰
const fiberNode = {
  type: MyComponent,           // ç»„ä»¶å‡½æ•°
  memoizedState: hookList,     // Hook é“¾è¡¨
  memoizedProps: props,        // ä¸Šæ¬¡çš„ props
  pendingProps: newProps,      // æ–°çš„ props
  // ... å…¶ä»–å±æ€§
};

// Hook é“¾è¡¨ç»“æ„
const hookList = {
  // ç¬¬ä¸€ä¸ª Hook (useState)
  memoizedState: 0,           // å½“å‰çŠ¶æ€å€¼
  queue: updateQueue,         // æ›´æ–°é˜Ÿåˆ—
  next: hook2,                // ä¸‹ä¸€ä¸ª Hook
  
  // ç¬¬äºŒä¸ª Hook (useEffect)
  hook2: {
    memoizedState: {
      create: effectFunction,   // å‰¯ä½œç”¨å‡½æ•°
      destroy: cleanupFunction, // æ¸…ç†å‡½æ•°
      deps: [count],           // ä¾èµ–æ•°ç»„
    },
    next: hook3,
  },
  
  // ... æ›´å¤š Hook
};
```

### Hook çŠ¶æ€çš„è¯»å–å’Œæ›´æ–°

```javascript
// åœ¨ react-reconciler/src/ReactFiberHooks.js ä¸­

// å…¨å±€å˜é‡ï¼Œè·Ÿè¸ªå½“å‰æ¸²æŸ“çš„ç»„ä»¶å’Œ Hook
let currentlyRenderingFiber = null;
let currentHook = null;
let workInProgressHook = null;

function renderWithHooks(current, workInProgress, Component, props) {
  // è®¾ç½®å½“å‰æ¸²æŸ“çš„ Fiber
  currentlyRenderingFiber = workInProgress;
  
  // é‡ç½® Hook çŠ¶æ€
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  
  // è®¾ç½® Hook dispatcher
  ReactCurrentDispatcher.current = 
    current === null || current.memoizedState === null
      ? HooksDispatcherOnMount      // é¦–æ¬¡æ¸²æŸ“
      : HooksDispatcherOnUpdate;    // æ›´æ–°æ¸²æŸ“
  
  // è°ƒç”¨ç»„ä»¶å‡½æ•°
  let children = Component(props, secondArg);
  
  // æ¸…ç†å…¨å±€çŠ¶æ€
  currentlyRenderingFiber = null;
  currentHook = null;
  workInProgressHook = null;
  
  return children;
}
```

### æ¡ˆä¾‹ 4ï¼šæ·±å…¥ç†è§£ Hook çŠ¶æ€å­˜å‚¨

```javascript
// è°ƒè¯• Hook çŠ¶æ€å­˜å‚¨çš„å·¥å…·å‡½æ•°
function debugFiberHooks(componentName) {
  // è·å–å½“å‰ç»„ä»¶çš„ Fiber èŠ‚ç‚¹
  const getCurrentFiber = () => {
    const reactInternalInstance = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentFiber;
    return reactInternalInstance?.current;
  };
  
  // è§£æ Hook é“¾è¡¨
  const parseHookList = (memoizedState) => {
    const hooks = [];
    let currentHook = memoizedState;
    let index = 0;
    
    while (currentHook) {
      hooks.push({
        index,
        type: getHookType(currentHook),
        memoizedState: currentHook.memoizedState,
        hasQueue: !!currentHook.queue,
        hasNext: !!currentHook.next
      });
      
      currentHook = currentHook.next;
      index++;
    }
    
    return hooks;
  };
  
  // æ¨æ–­ Hook ç±»å‹
  const getHookType = (hook) => {
    if (hook.queue) {
      return 'State Hook (useState/useReducer)';
    } else if (Array.isArray(hook.memoizedState)) {
      return 'Memo Hook (useMemo/useCallback)';
    } else if (hook.memoizedState && typeof hook.memoizedState === 'object' && hook.memoizedState.current !== undefined) {
      return 'Ref Hook (useRef)';
    } else if (hook.memoizedState && typeof hook.memoizedState === 'object' && hook.memoizedState.create) {
      return 'Effect Hook (useEffect/useLayoutEffect)';
    } else {
      return 'Unknown Hook';
    }
  };
  
  return () => {
    const fiber = getCurrentFiber();
    if (fiber) {
      const hooks = parseHookList(fiber.memoizedState);
      console.group(`ğŸ” ${componentName} Hook çŠ¶æ€åˆ†æ`);
      console.log('Fiber èŠ‚ç‚¹:', fiber);
      console.log('Hook é“¾è¡¨:', fiber.memoizedState);
      console.table(hooks);
      console.groupEnd();
    }
  };
}

// æ¼”ç¤º Hook çŠ¶æ€å­˜å‚¨çš„ç»„ä»¶
function HookStorageDemo() {
  // åˆ›å»ºè°ƒè¯•å‡½æ•°
  const debugHooks = debugFiberHooks('HookStorageDemo');
  
  // å„ç§ç±»å‹çš„ Hook
  const [count, setCount] = useState(0);
  const [text, setText] = useState('Hello');
  const [visible, setVisible] = useState(true);
  
  const inputRef = useRef(null);
  
  const doubledCount = useMemo(() => {
    console.log('ğŸ§® useMemo è®¡ç®—æ‰§è¡Œ');
    return count * 2;
  }, [count]);
  
  const handleClick = useCallback(() => {
    setCount(prev => prev + 1);
  }, []);
  
  useEffect(() => {
    console.log('ğŸ‘€ useEffect: count å˜åŒ–ä¸º', count);
  }, [count]);
  
  useLayoutEffect(() => {
    if (inputRef.current) {
      inputRef.current.style.backgroundColor = visible ? 'lightblue' : 'lightcoral';
    }
  }, [visible]);
  
  // åœ¨æ¯æ¬¡æ¸²æŸ“åè°ƒè¯• Hook çŠ¶æ€
  useEffect(() => {
    debugHooks();
  });
  
  return (
    <div style={{ padding: '20px', border: '1px solid #ccc' }}>
      <h3>Hook çŠ¶æ€å­˜å‚¨æ¼”ç¤º</h3>
      
      <div>
        <p>è®¡æ•°: {count} (åŒå€: {doubledCount})</p>
        <button onClick={handleClick}>å¢åŠ è®¡æ•°</button>
      </div>
      
      <div>
        <input
          ref={inputRef}
          type="text"
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="è¾“å…¥æ–‡æœ¬"
        />
      </div>
      
      <div>
        <label>
          <input
            type="checkbox"
            checked={visible}
            onChange={(e) => setVisible(e.target.checked)}
          />
          æ˜¾ç¤ºç‰¹æ•ˆ
        </label>
      </div>
      
      <button onClick={debugHooks} style={{ marginTop: '10px' }}>
        æ‰‹åŠ¨è°ƒè¯• Hook çŠ¶æ€
      </button>
    </div>
  );
}
```

## Hook Dispatcher æœºåˆ¶

### ä¸åŒé˜¶æ®µçš„ Dispatcher

React æ ¹æ®ç»„ä»¶çš„æ¸²æŸ“é˜¶æ®µä½¿ç”¨ä¸åŒçš„ Hook dispatcherï¼š

```javascript
// æŒ‚è½½é˜¶æ®µçš„ dispatcher
const HooksDispatcherOnMount = {
  useState: mountState,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
  useMemo: mountMemo,
  useCallback: mountCallback,
  useRef: mountRef,
  // ... å…¶ä»– Hook
};

// æ›´æ–°é˜¶æ®µçš„ dispatcher
const HooksDispatcherOnUpdate = {
  useState: updateState,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useCallback: updateCallback,
  useRef: updateRef,
  // ... å…¶ä»– Hook
};

// é‡æ–°æ¸²æŸ“é˜¶æ®µçš„ dispatcher
const HooksDispatcherOnRerender = {
  useState: rerenderState,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useCallback: updateCallback,
  useRef: updateRef,
  // ... å…¶ä»– Hook
};
```

### useState çš„ä¸åŒå®ç°

```javascript
// æŒ‚è½½æ—¶çš„ useState
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  
  if (typeof initialState === 'function') {
    initialState = initialState();
  }
  
  hook.memoizedState = hook.baseState = initialState;
  
  const queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  };
  hook.queue = queue;
  
  const dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
  queue.dispatch = dispatch;
  
  return [hook.memoizedState, dispatch];
}

// æ›´æ–°æ—¶çš„ useState
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}

// é‡æ–°æ¸²æŸ“æ—¶çš„ useState
function rerenderState(initialState) {
  return rerenderReducer(basicStateReducer, initialState);
}
```

### æ¡ˆä¾‹ 5ï¼šDispatcher åˆ‡æ¢å¯è§†åŒ–

```javascript
// æ¼”ç¤ºä¸åŒé˜¶æ®µ Dispatcher çš„åˆ‡æ¢
function DispatcherDemo() {
  const [mountPhase, setMountPhase] = useState(true);
  const [updateCount, setUpdateCount] = useState(0);
  const [rerenderCount, setRerenderCount] = useState(0);
  
  // è·Ÿè¸ªå½“å‰ Dispatcher ç±»å‹
  const currentDispatcher = useRef('unknown');
  
  // åœ¨ä¸åŒé˜¶æ®µè®°å½• Dispatcher ç±»å‹
  useEffect(() => {
    if (mountPhase) {
      currentDispatcher.current = 'HooksDispatcherOnMount';
      console.log('ğŸ¯ å½“å‰ä½¿ç”¨æŒ‚è½½é˜¶æ®µ Dispatcher');
      setMountPhase(false);
    } else {
      currentDispatcher.current = 'HooksDispatcherOnUpdate';
      console.log('ğŸ”„ å½“å‰ä½¿ç”¨æ›´æ–°é˜¶æ®µ Dispatcher');
    }
  });
  
  // è§¦å‘é‡æ–°æ¸²æŸ“çš„ç‰¹æ®Šæƒ…å†µ
  const triggerRerender = () => {
    console.log('ğŸ”¥ å³å°†è§¦å‘é‡æ–°æ¸²æŸ“ Dispatcher');
    // åœ¨æ¸²æŸ“è¿‡ç¨‹ä¸­è°ƒç”¨ setState ä¼šè§¦å‘é‡æ–°æ¸²æŸ“
    setRerenderCount(prev => {
      setUpdateCount(count => count + 1); // è¿™ä¼šè§¦å‘ rerender
      return prev + 1;
    });
  };
  
  return (
    <div style={{ padding: '20px', border: '2px solid #007acc' }}>
      <h3>Dispatcher åˆ‡æ¢æ¼”ç¤º</h3>
      
      <div>
        <p>å½“å‰ Dispatcher: <strong>{currentDispatcher.current}</strong></p>
        <p>æ›´æ–°æ¬¡æ•°: {updateCount}</p>
        <p>é‡æ–°æ¸²æŸ“æ¬¡æ•°: {rerenderCount}</p>
      </div>
      
      <div>
        <button onClick={() => setUpdateCount(prev => prev + 1)}>
          æ™®é€šæ›´æ–° (ä½¿ç”¨ UpdateDispatcher)
        </button>
        
        <button onClick={triggerRerender} style={{ marginLeft: '10px' }}>
          è§¦å‘é‡æ–°æ¸²æŸ“ (ä½¿ç”¨ RerenderDispatcher)
        </button>
      </div>
      
      <div style={{ marginTop: '10px', fontSize: '12px', color: '#666' }}>
        <p>ğŸ’¡ æ‰“å¼€å¼€å‘è€…å·¥å…·æŸ¥çœ‹ä¸åŒ Dispatcher çš„åˆ‡æ¢æ—¥å¿—</p>
      </div>
    </div>
  );
}
```

## Hook è°ƒç”¨é¡ºåºçš„ä¿è¯æœºåˆ¶

### Hook ç´¢å¼•æœºåˆ¶

React é€šè¿‡ Hook è°ƒç”¨çš„é¡ºåºæ¥å»ºç«‹ç´¢å¼•å…³ç³»ï¼š

```javascript
function MyComponent() {
  // Hook è°ƒç”¨é¡ºåº:
  const [state1, setState1] = useState(1);    // ç´¢å¼• 0
  const [state2, setState2] = useState(2);    // ç´¢å¼• 1
  const [state3, setState3] = useState(3);    // ç´¢å¼• 2
  
  useEffect(() => {                           // ç´¢å¼• 3
    console.log('effect 1');
  }, [state1]);
  
  useEffect(() => {                           // ç´¢å¼• 4
    console.log('effect 2');
  }, [state2]);
  
  return <div>{state1 + state2 + state3}</div>;
}
```

### Hook é“¾è¡¨éå†

```javascript
function updateWorkInProgressHook() {
  let nextCurrentHook;
  
  if (currentHook === null) {
    // è¿™æ˜¯ç»„ä»¶ä¸­çš„ç¬¬ä¸€ä¸ª Hook
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    // è·å–é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ª Hook
    nextCurrentHook = currentHook.next;
  }
  
  let nextWorkInProgressHook;
  if (workInProgressHook === null) {
    // è¿™æ˜¯ç»„ä»¶ä¸­çš„ç¬¬ä¸€ä¸ª Hook
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    // è·å–é“¾è¡¨ä¸­çš„ä¸‹ä¸€ä¸ª Hook
    nextWorkInProgressHook = workInProgressHook.next;
  }
  
  if (nextWorkInProgressHook !== null) {
    // å·²æœ‰ workInProgress Hookï¼Œå¤ç”¨
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    // åˆ›å»ºæ–°çš„ workInProgress Hook
    currentHook = nextCurrentHook;
    
    const newHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null,
    };
    
    if (workInProgressHook === null) {
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  
  return workInProgressHook;
}
```

### æ¡ˆä¾‹ 6ï¼šHook é¡ºåºè¿åæ£€æµ‹

```javascript
// æ¼”ç¤º Hook é¡ºåºè§„åˆ™å’Œæ£€æµ‹æœºåˆ¶
function HookOrderDemo() {
  const [showConditional, setShowConditional] = useState(false);
  const [count, setCount] = useState(0);
  
  // âŒ é”™è¯¯ç¤ºä¾‹ï¼šæ¡ä»¶æ€§è°ƒç”¨ Hookï¼ˆä»…ç”¨äºæ¼”ç¤ºï¼Œå®é™…ä¼šæŠ¥é”™ï¼‰
  // if (showConditional) {
  //   const [conditionalState] = useState('bad practice');
  // }
  
  // âœ… æ­£ç¡®åšæ³•ï¼šHook æ€»æ˜¯åœ¨é¡¶å±‚è°ƒç”¨
  const [conditionalState, setConditionalState] = useState('');
  
  // é€šè¿‡çŠ¶æ€æ§åˆ¶é€»è¾‘ï¼Œè€Œä¸æ˜¯æ§åˆ¶ Hook è°ƒç”¨
  useEffect(() => {
    if (showConditional) {
      setConditionalState('conditional logic activated');
    } else {
      setConditionalState('');
    }
  }, [showConditional]);
  
  // Hook è°ƒç”¨é¡ºåºå¯è§†åŒ–
  const hookOrder = [
    { name: 'useState(showConditional)', index: 0, active: true },
    { name: 'useState(count)', index: 1, active: true },
    { name: 'useState(conditionalState)', index: 2, active: true },
    { name: 'useEffect(conditional logic)', index: 3, active: true },
    { name: 'useMemo(hookOrder)', index: 4, active: true }
  ];
  
  const memoizedOrder = useMemo(() => hookOrder, []);
  
  return (
    <div style={{ padding: '20px', border: '2px solid #28a745' }}>
      <h3>Hook è°ƒç”¨é¡ºåºæ¼”ç¤º</h3>
      
      <div>
        <label>
          <input
            type="checkbox"
            checked={showConditional}
            onChange={(e) => setShowConditional(e.target.checked)}
          />
          æ˜¾ç¤ºæ¡ä»¶é€»è¾‘
        </label>
      </div>
      
      <div>
        <p>è®¡æ•°: {count}</p>
        <button onClick={() => setCount(prev => prev + 1)}>
          å¢åŠ è®¡æ•°
        </button>
      </div>
      
      {showConditional && (
        <div style={{ backgroundColor: '#d4edda', padding: '10px', margin: '10px 0' }}>
          <p>æ¡ä»¶çŠ¶æ€: {conditionalState}</p>
        </div>
      )}
      
      <div style={{ marginTop: '20px' }}>
        <h4>Hook è°ƒç”¨é¡ºåº (ç´¢å¼•ä¿æŒä¸€è‡´):</h4>
        <ol>
          {memoizedOrder.map((hook, idx) => (
            <li key={idx} style={{ 
              color: hook.active ? '#28a745' : '#dc3545',
              fontFamily: 'monospace'
            }}>
              {hook.name} - ç´¢å¼•: {hook.index}
            </li>
          ))}
        </ol>
      </div>
      
      <div style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
        <p>âœ… æ‰€æœ‰ Hook éƒ½åœ¨ç»„ä»¶é¡¶å±‚è°ƒç”¨ï¼Œç´¢å¼•ä¿æŒç¨³å®š</p>
        <p>âœ… é€šè¿‡çŠ¶æ€æ§åˆ¶æ¸²æŸ“é€»è¾‘ï¼Œè€Œä¸æ˜¯æ§åˆ¶ Hook è°ƒç”¨</p>
      </div>
    </div>
  );
}
```

## çŠ¶æ€æ›´æ–°çš„å®Œæ•´æµç¨‹

### çŠ¶æ€æ›´æ–°è§¦å‘

```javascript
function MyComponent() {
  const [count, setCount] = useState(0);
  
  const handleClick = () => {
    // è§¦å‘çŠ¶æ€æ›´æ–°
    setCount(count + 1);
  };
  
  return <button onClick={handleClick}>Count: {count}</button>;
}
```

### dispatchSetState å®ç°

```javascript
function dispatchSetState(fiber, queue, action) {
  const eventTime = requestEventTime();
  const lane = requestUpdateLane(fiber);
  
  const update = {
    lane,
    action,
    eagerReducer: null,
    eagerState: null,
    next: null,
  };
  
  // å°è¯•ç«‹å³è®¡ç®—æ–°çŠ¶æ€ï¼ˆeager evaluationï¼‰
  if (fiber.lanes === NoLanes && (fiber.alternate === null || fiber.alternate.lanes === NoLanes)) {
    const lastRenderedReducer = queue.lastRenderedReducer;
    if (lastRenderedReducer !== null) {
      try {
        const currentState = queue.lastRenderedState;
        const eagerState = lastRenderedReducer(currentState, action);
        
        update.eagerReducer = lastRenderedReducer;
        update.eagerState = eagerState;
        
        if (is(eagerState, currentState)) {
          // çŠ¶æ€æ²¡æœ‰å˜åŒ–ï¼Œè·³è¿‡æ›´æ–°
          return;
        }
      } catch (error) {
        // è®¡ç®—å¤±è´¥ï¼Œç»§ç»­æ­£å¸¸æµç¨‹
      }
    }
  }
  
  // å°†æ›´æ–°åŠ å…¥é˜Ÿåˆ—
  enqueueUpdate(fiber, update);
  
  // è°ƒåº¦æ›´æ–°
  scheduleUpdateOnFiber(fiber, lane, eventTime);
}
```

### æ¡ˆä¾‹ 7ï¼šçŠ¶æ€æ›´æ–°å…¨æµç¨‹è¿½è¸ª

```javascript
// æ·±å…¥è¿½è¸ªçŠ¶æ€æ›´æ–°çš„æ¯ä¸ªæ­¥éª¤
function StateUpdateFlowTracker() {
  const [count, setCount] = useState(0);
  const [updateHistory, setUpdateHistory] = useState([]);
  
  // åˆ›å»ºå¢å¼ºçš„ setState å‡½æ•°æ¥è¿½è¸ªæ›´æ–°æµç¨‹
  const trackedSetCount = useCallback((newValue) => {
    const timestamp = Date.now();
    const updateId = Math.random().toString(36).substr(2, 9);
    
    console.group(`ğŸš€ çŠ¶æ€æ›´æ–°å¼€å§‹ - ID: ${updateId}`);
    console.log('1ï¸âƒ£ ç”¨æˆ·è°ƒç”¨ setCount');
    console.log('2ï¸âƒ£ åˆ›å»º update å¯¹è±¡');
    console.log('3ï¸âƒ£ å°† update åŠ å…¥é˜Ÿåˆ—');
    console.log('4ï¸âƒ£ è°ƒåº¦æ›´æ–° (scheduleUpdateOnFiber)');
    
    // è®°å½•æ›´æ–°å†å²
    setUpdateHistory(prev => [
      ...prev,
      {
        id: updateId,
        timestamp,
        oldValue: count,
        newValue: typeof newValue === 'function' ? newValue(count) : newValue,
        type: typeof newValue === 'function' ? 'function' : 'value'
      }
    ]);
    
    // å®é™…æ›´æ–°çŠ¶æ€
    setCount(newValue);
    
    console.log('5ï¸âƒ£ æ¸²æŸ“é˜¶æ®µå³å°†å¼€å§‹');
    console.groupEnd();
  }, [count]);
  
  // ç›‘å¬çŠ¶æ€å˜åŒ–
  useEffect(() => {
    console.log('âœ… çŠ¶æ€æ›´æ–°å®Œæˆï¼Œæ–°å€¼:', count);
    console.log('ğŸ”„ ç»„ä»¶é‡æ–°æ¸²æŸ“å®Œæˆ');
  }, [count]);
  
  // æ‰¹é‡æ›´æ–°æ¼”ç¤º
  const batchUpdate = () => {
    console.log('ğŸ¯ å¼€å§‹æ‰¹é‡æ›´æ–°');
    
    // React ä¼šè‡ªåŠ¨æ‰¹å¤„ç†è¿™äº›æ›´æ–°
    trackedSetCount(prev => prev + 1);
    trackedSetCount(prev => prev + 1);
    trackedSetCount(prev => prev + 1);
    
    console.log('ğŸ“¦ æ‰¹é‡æ›´æ–°è°ƒç”¨å®Œæˆï¼Œç­‰å¾… React æ‰¹å¤„ç†');
  };
  
  // å¼‚æ­¥æ›´æ–°æ¼”ç¤º
  const asyncUpdate = async () => {
    console.log('â° å¼€å§‹å¼‚æ­¥æ›´æ–°');
    
    setTimeout(() => {
      console.log('ğŸ• setTimeout å›è°ƒæ‰§è¡Œ');
      trackedSetCount(prev => prev + 10);
    }, 100);
    
    // React 18 çš„è‡ªåŠ¨æ‰¹å¤„ç†
    await Promise.resolve();
    console.log('ğŸ‰ Promise å®Œæˆåæ›´æ–°');
    trackedSetCount(prev => prev + 5);
  };
  
  return (
    <div style={{ padding: '20px', border: '2px solid #ff6b6b' }}>
      <h3>çŠ¶æ€æ›´æ–°æµç¨‹è¿½è¸ª</h3>
      
      <div>
        <p>å½“å‰è®¡æ•°: <strong>{count}</strong></p>
      </div>
      
      <div style={{ marginBottom: '20px' }}>
        <button onClick={() => trackedSetCount(count + 1)}>
          æ™®é€šæ›´æ–° (+1)
        </button>
        
        <button onClick={() => trackedSetCount(prev => prev * 2)} style={{ marginLeft: '10px' }}>
          å‡½æ•°æ›´æ–° (Ã—2)
        </button>
        
        <button onClick={batchUpdate} style={{ marginLeft: '10px' }}>
          æ‰¹é‡æ›´æ–° (+3)
        </button>
        
        <button onClick={asyncUpdate} style={{ marginLeft: '10px' }}>
          å¼‚æ­¥æ›´æ–° (+15)
        </button>
      </div>
      
      <div>
        <h4>æ›´æ–°å†å²:</h4>
        <div style={{ maxHeight: '200px', overflow: 'auto', backgroundColor: '#f8f9fa', padding: '10px' }}>
          {updateHistory.map((update) => (
            <div key={update.id} style={{ marginBottom: '5px', fontSize: '12px' }}>
              <strong>ID:</strong> {update.id} |
              <strong> æ—¶é—´:</strong> {new Date(update.timestamp).toLocaleTimeString()} |
              <strong> å˜åŒ–:</strong> {update.oldValue} â†’ {update.newValue} |
              <strong> ç±»å‹:</strong> {update.type}
            </div>
          ))}
        </div>
      </div>
      
      <div style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
        <p>ğŸ’¡ æ‰“å¼€å¼€å‘è€…å·¥å…·æŸ¥çœ‹è¯¦ç»†çš„çŠ¶æ€æ›´æ–°æµç¨‹</p>
      </div>
    </div>
  );
}
```

## å‰¯ä½œç”¨çš„å¤„ç†æœºåˆ¶

### useEffect çš„å®ç°

```javascript
function mountEffect(create, deps) {
  return mountEffectImpl(
    PassiveEffect | PassiveStaticEffect,
    HookPassive,
    create,
    deps,
  );
}

function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  
  currentlyRenderingFiber.flags |= fiberFlags;
  
  hook.memoizedState = pushEffect(
    HookHasEffect | hookFlags,
    create,
    undefined,
    nextDeps,
  );
}

function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect === null) {
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  
  return effect;
}
```

### å‰¯ä½œç”¨çš„æ‰§è¡Œæ—¶æœº

```javascript
// åœ¨ commit é˜¶æ®µæ‰§è¡Œå‰¯ä½œç”¨
function commitPassiveEffects(finishedWork) {
  const updateQueue = finishedWork.updateQueue;
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    
    do {
      const { create, destroy, deps } = effect;
      
      if ((effect.tag & HookPassive) !== NoHookEffect) {
        // æ‰§è¡Œé”€æ¯å‡½æ•°
        if (destroy !== undefined) {
          destroy();
        }
        
        // æ‰§è¡Œåˆ›å»ºå‡½æ•°
        const destroyFunc = create();
        if (typeof destroyFunc === 'function') {
          effect.destroy = destroyFunc;
        }
      }
      
      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
```

### æ¡ˆä¾‹ 8ï¼šå‰¯ä½œç”¨æ‰§è¡Œæ—¶æœºæ¼”ç¤º

```javascript
// æ¼”ç¤ºä¸åŒç±»å‹å‰¯ä½œç”¨çš„æ‰§è¡Œæ—¶æœºå’Œé¡ºåº
function EffectTimingDemo() {
  const [count, setCount] = useState(0);
  const [mounted, setMounted] = useState(false);
  
  // useLayoutEffect - åŒæ­¥æ‰§è¡Œï¼Œåœ¨ DOM æ›´æ–°åç«‹å³æ‰§è¡Œ
  useLayoutEffect(() => {
    console.log('ğŸ¨ useLayoutEffect: DOM æ›´æ–°ååŒæ­¥æ‰§è¡Œ');
    console.log('ğŸ“ å¯ä»¥åŒæ­¥è¯»å– DOM å°ºå¯¸å’Œæ ·å¼');
    
    return () => {
      console.log('ğŸ§¹ useLayoutEffect æ¸…ç†: åŒæ­¥æ¸…ç†');
    };
  }, [count]);
  
  // useEffect - å¼‚æ­¥æ‰§è¡Œï¼Œåœ¨æ¸²æŸ“å®Œæˆåå¼‚æ­¥æ‰§è¡Œ
  useEffect(() => {
    console.log('âš¡ useEffect: æ¸²æŸ“å®Œæˆåå¼‚æ­¥æ‰§è¡Œ');
    console.log('ğŸŒ é€‚åˆæ•°æ®è·å–ã€è®¢é˜…ç­‰å‰¯ä½œç”¨');
    
    return () => {
      console.log('ğŸ§¹ useEffect æ¸…ç†: å¼‚æ­¥æ¸…ç†');
    };
  }, [count]);
  
  // æŒ‚è½½æ—¶çš„å‰¯ä½œç”¨
  useEffect(() => {
    console.log('ğŸ¬ ç»„ä»¶æŒ‚è½½å®Œæˆ');
    setMounted(true);
    
    // æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
    const timer = setTimeout(() => {
      console.log('â° å¼‚æ­¥æ“ä½œå®Œæˆ');
    }, 1000);
    
    return () => {
      console.log('ğŸ’€ ç»„ä»¶å³å°†å¸è½½');
      clearTimeout(timer);
      setMounted(false);
    };
  }, []);
  
  // æ¡ä»¶å‰¯ä½œç”¨
  useEffect(() => {
    if (count > 0) {
      console.log(`ğŸ“Š è®¡æ•°å¤§äº0: ${count}`);
      document.title = `è®¡æ•°: ${count}`;
    }
    
    return () => {
      if (count > 0) {
        console.log(`ğŸ”„ é‡ç½®æ–‡æ¡£æ ‡é¢˜`);
        document.title = 'å‰¯ä½œç”¨æ¼”ç¤º';
      }
    };
  }, [count]);
  
  // å‰¯ä½œç”¨æ‰§è¡Œé¡ºåºå¯è§†åŒ–
  const executionOrder = [
    '1. ç»„ä»¶å‡½æ•°æ‰§è¡Œ',
    '2. useState åˆ›å»º/æ›´æ–°çŠ¶æ€',
    '3. æ³¨å†Œ useLayoutEffect',
    '4. æ³¨å†Œ useEffect',
    '5. è¿”å› JSX',
    '6. React æ›´æ–° DOM',
    '7. æ‰§è¡Œ useLayoutEffect (åŒæ­¥)',
    '8. æµè§ˆå™¨ç»˜åˆ¶é¡µé¢',
    '9. æ‰§è¡Œ useEffect (å¼‚æ­¥)'
  ];
  
  return (
    <div style={{ padding: '20px', border: '2px solid #8e44ad' }}>
      <h3>å‰¯ä½œç”¨æ‰§è¡Œæ—¶æœºæ¼”ç¤º</h3>
      
      <div>
        <p>å½“å‰è®¡æ•°: <strong>{count}</strong></p>
        <p>ç»„ä»¶çŠ¶æ€: {mounted ? 'å·²æŒ‚è½½' : 'æœªæŒ‚è½½'}</p>
      </div>
      
      <div style={{ marginBottom: '20px' }}>
        <button onClick={() => setCount(prev => prev + 1)}>
          å¢åŠ è®¡æ•° (è§¦å‘å‰¯ä½œç”¨)
        </button>
        
        <button onClick={() => setCount(0)} style={{ marginLeft: '10px' }}>
          é‡ç½®è®¡æ•°
        </button>
      </div>
      
      <div>
        <h4>å‰¯ä½œç”¨æ‰§è¡Œé¡ºåº:</h4>
        <ol style={{ fontSize: '14px' }}>
          {executionOrder.map((step, index) => (
            <li key={index} style={{
              color: index < 6 ? '#2ecc71' : index < 8 ? '#e67e22' : '#9b59b6',
              marginBottom: '2px'
            }}>
              {step}
            </li>
          ))}
        </ol>
      </div>
      
      <div style={{ fontSize: '12px', color: '#666', marginTop: '10px' }}>
        <p>ğŸŸ¢ æ¸²æŸ“é˜¶æ®µ | ğŸŸ  Layout é˜¶æ®µ | ğŸŸ£ Effect é˜¶æ®µ</p>
        <p>ğŸ’¡ æŸ¥çœ‹æ§åˆ¶å°äº†è§£å‰¯ä½œç”¨çš„å®é™…æ‰§è¡Œé¡ºåº</p>
      </div>
    </div>
  );
}
```

## è‡ªå®šä¹‰ Hook çš„å®ç°åŸç†

### è‡ªå®šä¹‰ Hook çš„æœ¬è´¨

è‡ªå®šä¹‰ Hook æœ¬è´¨ä¸Šæ˜¯è°ƒç”¨å…¶ä»– Hook çš„ JavaScript å‡½æ•°ï¼š

```javascript
// è‡ªå®šä¹‰ Hookï¼šè®¡æ•°å™¨
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  
  const increment = useCallback(() => {
    setCount(c => c + 1);
  }, []);
  
  const decrement = useCallback(() => {
    setCount(c => c - 1);
  }, []);
  
  const reset = useCallback(() => {
    setCount(initialValue);
  }, [initialValue]);
  
  return { count, increment, decrement, reset };
}

// ä½¿ç”¨è‡ªå®šä¹‰ Hook
function Counter() {
  const { count, increment, decrement, reset } = useCounter(10);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

### å¤æ‚è‡ªå®šä¹‰ Hook ç¤ºä¾‹

```javascript
// æ•°æ®è·å– Hook
function useAsyncData(url, deps = []) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const result = await response.json();
      setData(result);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [url]);
  
  useEffect(() => {
    fetchData();
  }, [fetchData, ...deps]);
  
  const refetch = useCallback(() => {
    fetchData();
  }, [fetchData]);
  
  return { data, loading, error, refetch };
}

// ä½¿ç”¨æ•°æ®è·å– Hook
function UserProfile({ userId }) {
  const { data: user, loading, error, refetch } = useAsyncData(
    `/api/users/${userId}`,
    [userId]
  );
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <h1>{user?.name}</h1>
      <p>{user?.email}</p>
      <button onClick={refetch}>åˆ·æ–°</button>
    </div>
  );
}
```

### æ¡ˆä¾‹ 9ï¼šä¼ä¸šçº§è‡ªå®šä¹‰ Hook æ¶æ„

```javascript
// é«˜çº§æ•°æ®ç®¡ç† Hook
function useAsyncResource(config) {
  const {
    fetcher,           // æ•°æ®è·å–å‡½æ•°
    key,              // ç¼“å­˜é”®
    dependencies = [], // ä¾èµ–æ•°ç»„
    cacheTime = 300000, // ç¼“å­˜æ—¶é—´ (5åˆ†é’Ÿ)
    staleTime = 60000,  // æ•°æ®è¿‡æœŸæ—¶é—´ (1åˆ†é’Ÿ)
    retry = 3,         // é‡è¯•æ¬¡æ•°
    onSuccess,         // æˆåŠŸå›è°ƒ
    onError           // é”™è¯¯å›è°ƒ
  } = config;
  
  const [state, setState] = useState({
    data: null,
    loading: true,
    error: null,
    lastFetched: null,
    retryCount: 0
  });
  
  const cacheRef = useRef(new Map());
  const abortControllerRef = useRef(null);
  
  // æ£€æŸ¥ç¼“å­˜
  const getCachedData = useCallback((cacheKey) => {
    const cached = cacheRef.current.get(cacheKey);
    if (!cached) return null;
    
    const now = Date.now();
    const isStale = now - cached.timestamp > staleTime;
    const isExpired = now - cached.timestamp > cacheTime;
    
    if (isExpired) {
      cacheRef.current.delete(cacheKey);
      return null;
    }
    
    return { ...cached, isStale };
  }, [staleTime, cacheTime]);
  
  // è®¾ç½®ç¼“å­˜
  const setCachedData = useCallback((cacheKey, data) => {
    cacheRef.current.set(cacheKey, {
      data,
      timestamp: Date.now()
    });
  }, []);
  
  // æ•°æ®è·å–é€»è¾‘
  const fetchData = useCallback(async (retryCount = 0) => {
    const cacheKey = typeof key === 'function' ? key() : key;
    
    // æ£€æŸ¥ç¼“å­˜
    const cached = getCachedData(cacheKey);
    if (cached && !cached.isStale) {
      setState(prev => ({ 
        ...prev, 
        data: cached.data, 
        loading: false, 
        error: null 
      }));
      return cached.data;
    }
    
    // å–æ¶ˆä¹‹å‰çš„è¯·æ±‚
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    
    abortControllerRef.current = new AbortController();
    
    try {
      setState(prev => ({ 
        ...prev, 
        loading: true, 
        error: null, 
        retryCount 
      }));
      
      const data = await fetcher({ 
        signal: abortControllerRef.current.signal,
        dependencies 
      });
      
      // ç¼“å­˜æ•°æ®
      setCachedData(cacheKey, data);
      
      setState({
        data,
        loading: false,
        error: null,
        lastFetched: Date.now(),
        retryCount: 0
      });
      
      onSuccess?.(data);
      return data;
      
    } catch (error) {
      if (error.name === 'AbortError') {
        return; // å¿½ç•¥å–æ¶ˆçš„è¯·æ±‚
      }
      
      // é‡è¯•é€»è¾‘
      if (retryCount < retry) {
        console.log(`é‡è¯•ç¬¬ ${retryCount + 1} æ¬¡...`);
        setTimeout(() => {
          fetchData(retryCount + 1);
        }, Math.pow(2, retryCount) * 1000); // æŒ‡æ•°é€€é¿
        return;
      }
      
      setState(prev => ({ 
        ...prev, 
        loading: false, 
        error: error.message,
        retryCount 
      }));
      
      onError?.(error);
      throw error;
    }
  }, [fetcher, key, dependencies, retry, onSuccess, onError, getCachedData, setCachedData]);
  
  // è‡ªåŠ¨è·å–æ•°æ®
  useEffect(() => {
    fetchData();
    
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, [fetchData]);
  
  // æ‰‹åŠ¨åˆ·æ–°
  const refresh = useCallback(() => {
    const cacheKey = typeof key === 'function' ? key() : key;
    cacheRef.current.delete(cacheKey);
    return fetchData();
  }, [key, fetchData]);
  
  // æ¸…ç†ç¼“å­˜
  const clearCache = useCallback(() => {
    cacheRef.current.clear();
  }, []);
  
  return {
    ...state,
    refresh,
    clearCache,
    isStale: state.lastFetched && (Date.now() - state.lastFetched > staleTime)
  };
}

// å¤æ‚è¡¨å•ç®¡ç† Hook
function useAdvancedForm(config) {
  const {
    initialValues = {},
    validationSchema,
    onSubmit,
    validateOnChange = true,
    validateOnBlur = true,
    enableReinitialize = false
  } = config;
  
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitCount, setSubmitCount] = useState(0);
  
  // é‡æ–°åˆå§‹åŒ–
  useEffect(() => {
    if (enableReinitialize) {
      setValues(initialValues);
      setErrors({});
      setTouched({});
    }
  }, [initialValues, enableReinitialize]);
  
  // éªŒè¯å‡½æ•°
  const validate = useCallback(async (valuesToValidate = values) => {
    if (!validationSchema) return {};
    
    try {
      await validationSchema.validate(valuesToValidate, { abortEarly: false });
      return {};
    } catch (error) {
      const newErrors = {};
      error.inner.forEach(err => {
        if (err.path) {
          newErrors[err.path] = err.message;
        }
      });
      return newErrors;
    }
  }, [validationSchema, values]);
  
  // è®¾ç½®å­—æ®µå€¼
  const setFieldValue = useCallback(async (field, value) => {
    const newValues = { ...values, [field]: value };
    setValues(newValues);
    
    if (validateOnChange) {
      const fieldErrors = await validate(newValues);
      setErrors(prev => ({ ...prev, [field]: fieldErrors[field] || null }));
    }
  }, [values, validateOnChange, validate]);
  
  // è®¾ç½®å­—æ®µä¸ºå·²è§¦æ‘¸
  const setFieldTouched = useCallback(async (field, isTouched = true) => {
    setTouched(prev => ({ ...prev, [field]: isTouched }));
    
    if (validateOnBlur && isTouched) {
      const fieldErrors = await validate();
      setErrors(prev => ({ ...prev, [field]: fieldErrors[field] || null }));
    }
  }, [validateOnBlur, validate]);
  
  // è¡¨å•æäº¤
  const handleSubmit = useCallback(async (e) => {
    if (e) e.preventDefault();
    
    setSubmitCount(prev => prev + 1);
    setIsSubmitting(true);
    
    try {
      const formErrors = await validate();
      
      if (Object.keys(formErrors).length > 0) {
        setErrors(formErrors);
        // æ ‡è®°æ‰€æœ‰å­—æ®µä¸ºå·²è§¦æ‘¸
        const allTouched = {};
        Object.keys(values).forEach(key => {
          allTouched[key] = true;
        });
        setTouched(allTouched);
        return;
      }
      
      await onSubmit?.(values);
      
    } catch (error) {
      console.error('è¡¨å•æäº¤é”™è¯¯:', error);
    } finally {
      setIsSubmitting(false);
    }
  }, [validate, values, onSubmit]);
  
  // é‡ç½®è¡¨å•
  const resetForm = useCallback(() => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
    setSubmitCount(0);
  }, [initialValues]);
  
  // è®¡ç®—æ˜¯å¦æœ‰æ•ˆ
  const isValid = useMemo(() => {
    return Object.keys(errors).length === 0;
  }, [errors]);
  
  // è®¡ç®—æ˜¯å¦ä¸ºè„æ•°æ®
  const isDirty = useMemo(() => {
    return JSON.stringify(values) !== JSON.stringify(initialValues);
  }, [values, initialValues]);
  
  return {
    values,
    errors,
    touched,
    isSubmitting,
    submitCount,
    isValid,
    isDirty,
    setFieldValue,
    setFieldTouched,
    handleSubmit,
    resetForm,
    validate
  };
}

// ä½¿ç”¨ç¤ºä¾‹
function EnterpriseFormExample() {
  // æ•°æ®è·å–
  const { data: userOptions, loading: optionsLoading } = useAsyncResource({
    fetcher: () => fetch('/api/users').then(r => r.json()),
    key: 'user-options',
    staleTime: 30000
  });
  
  // è¡¨å•ç®¡ç†
  const form = useAdvancedForm({
    initialValues: {
      name: '',
      email: '',
      role: ''
    },
    onSubmit: async (values) => {
      console.log('æäº¤è¡¨å•:', values);
      // æ¨¡æ‹Ÿæäº¤
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  });
  
  return (
    <div style={{ padding: '20px', border: '2px solid #3498db' }}>
      <h3>ä¼ä¸šçº§ Hook æ¶æ„æ¼”ç¤º</h3>
      
      <form onSubmit={form.handleSubmit}>
        <div style={{ marginBottom: '15px' }}>
          <label>å§“å:</label>
          <input
            type="text"
            value={form.values.name}
            onChange={(e) => form.setFieldValue('name', e.target.value)}
            onBlur={() => form.setFieldTouched('name')}
            style={{ marginLeft: '10px', padding: '5px' }}
          />
          {form.touched.name && form.errors.name && (
            <span style={{ color: 'red', marginLeft: '10px' }}>
              {form.errors.name}
            </span>
          )}
        </div>
        
        <div style={{ marginBottom: '15px' }}>
          <label>é‚®ç®±:</label>
          <input
            type="email"
            value={form.values.email}
            onChange={(e) => form.setFieldValue('email', e.target.value)}
            onBlur={() => form.setFieldTouched('email')}
            style={{ marginLeft: '10px', padding: '5px' }}
          />
        </div>
        
        <div style={{ marginBottom: '15px' }}>
          <label>è§’è‰²:</label>
          <select
            value={form.values.role}
            onChange={(e) => form.setFieldValue('role', e.target.value)}
            disabled={optionsLoading}
            style={{ marginLeft: '10px', padding: '5px' }}
          >
            <option value="">é€‰æ‹©è§’è‰²...</option>
            <option value="admin">ç®¡ç†å‘˜</option>
            <option value="user">ç”¨æˆ·</option>
          </select>
        </div>
        
        <div>
          <button 
            type="submit" 
            disabled={form.isSubmitting || !form.isValid}
            style={{ padding: '10px 20px' }}
          >
            {form.isSubmitting ? 'æäº¤ä¸­...' : 'æäº¤'}
          </button>
          
          <button 
            type="button" 
            onClick={form.resetForm}
            style={{ marginLeft: '10px', padding: '10px 20px' }}
          >
            é‡ç½®
          </button>
        </div>
      </form>
      
      <div style={{ marginTop: '20px', fontSize: '12px' }}>
        <p>è¡¨å•çŠ¶æ€: {form.isDirty ? 'å·²ä¿®æ”¹' : 'æœªä¿®æ”¹'} | 
           æœ‰æ•ˆæ€§: {form.isValid ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'} | 
           æäº¤æ¬¡æ•°: {form.submitCount}</p>
      </div>
    </div>
  );
}
```

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### Hook çš„æ€§èƒ½è€ƒé‡

```javascript
function OptimizedComponent({ items, filter }) {
  // âœ… ç¼“å­˜è®¡ç®—ç»“æœ
  const filteredItems = useMemo(() => {
    return items.filter(item => item.category === filter);
  }, [items, filter]);
  
  // âœ… ç¼“å­˜äº‹ä»¶å¤„ç†å‡½æ•°
  const handleItemClick = useCallback((id) => {
    console.log('ç‚¹å‡»é¡¹ç›®:', id);
  }, []);
  
  // âœ… åˆ†ç¦»ä¸ç›¸å…³çš„çŠ¶æ€
  const [selectedId, setSelectedId] = useState(null);
  const [isExpanded, setIsExpanded] = useState(false);
  
  // âœ… åˆç†ä½¿ç”¨ useEffect ä¾èµ–
  useEffect(() => {
    if (selectedId) {
      const item = items.find(item => item.id === selectedId);
      if (item) {
        analytics.track('item_selected', { category: item.category });
      }
    }
  }, [selectedId, items]); // åªåœ¨ selectedId æˆ– items å˜åŒ–æ—¶æ‰§è¡Œ
  
  return (
    <div>
      {filteredItems.map(item => (
        <OptimizedItem
          key={item.id}
          item={item}
          onClick={handleItemClick}
          isSelected={selectedId === item.id}
        />
      ))}
    </div>
  );
}

// ä½¿ç”¨ memo ä¼˜åŒ–å­ç»„ä»¶
const OptimizedItem = memo(function Item({ item, onClick, isSelected }) {
  return (
    <div 
      className={isSelected ? 'selected' : ''}
      onClick={() => onClick(item.id)}
    >
      {item.name}
    </div>
  );
});
```

### æ¡ˆä¾‹ 10ï¼šHook æ€§èƒ½ä¼˜åŒ–ç»¼åˆæ¡ˆä¾‹

```javascript
// é«˜æ€§èƒ½ç»„ä»¶ä¼˜åŒ–æ¡ˆä¾‹
function PerformanceOptimizedComponent({ items, categories, userId }) {
  // âœ… çŠ¶æ€åˆ†ç¦» - é¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [sortBy, setSortBy] = useState('name');
  const [viewMode, setViewMode] = useState('grid');
  
  // âœ… è®¡ç®—ç¼“å­˜ - é¿å…é‡å¤è®¡ç®—
  const filteredAndSortedItems = useMemo(() => {
    console.log('ğŸ§® é‡æ–°è®¡ç®—è¿‡æ»¤å’Œæ’åºçš„é¡¹ç›®');
    
    let result = items;
    
    // è¿‡æ»¤
    if (searchTerm) {
      result = result.filter(item => 
        item.name.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    if (selectedCategory !== 'all') {
      result = result.filter(item => item.category === selectedCategory);
    }
    
    // æ’åº
    result = [...result].sort((a, b) => {
      switch (sortBy) {
        case 'name':
          return a.name.localeCompare(b.name);
        case 'price':
          return a.price - b.price;
        case 'date':
          return new Date(b.createdAt) - new Date(a.createdAt);
        default:
          return 0;
      }
    });
    
    return result;
  }, [items, searchTerm, selectedCategory, sortBy]);
  
  // âœ… äº‹ä»¶å¤„ç†ç¼“å­˜ - é¿å…å­ç»„ä»¶ä¸å¿…è¦çš„é‡æ¸²æŸ“
  const handleItemSelect = useCallback((itemId) => {
    console.log('é€‰æ‹©é¡¹ç›®:', itemId);
    // è¿™é‡Œå¯èƒ½ä¼šè°ƒç”¨çˆ¶ç»„ä»¶çš„å›è°ƒ
  }, []);
  
  const handleItemFavorite = useCallback((itemId) => {
    console.log('æ”¶è—é¡¹ç›®:', itemId);
    // æ›´æ–°æ”¶è—çŠ¶æ€çš„é€»è¾‘
  }, []);
  
  // âœ… é˜²æŠ–æœç´¢ - å‡å°‘æœç´¢é¢‘ç‡
  const debouncedSearch = useMemo(() => {
    const timeoutRef = { current: null };
    
    return (value) => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      
      timeoutRef.current = setTimeout(() => {
        setSearchTerm(value);
      }, 300);
    };
  }, []);
  
  // âœ… è™šæ‹ŸåŒ–å‡†å¤‡ - å¤§åˆ—è¡¨æ€§èƒ½ä¼˜åŒ–
  const itemHeight = 120;
  const containerHeight = 600;
  const visibleItems = Math.ceil(containerHeight / itemHeight) + 2;
  
  const [scrollTop, setScrollTop] = useState(0);
  const startIndex = Math.floor(scrollTop / itemHeight);
  const endIndex = Math.min(startIndex + visibleItems, filteredAndSortedItems.length);
  const visibleItemsData = filteredAndSortedItems.slice(startIndex, endIndex);
  
  // âœ… ç”¨æˆ·åå¥½ç¼“å­˜
  const userPreferences = useMemo(() => {
    return {
      preferredView: viewMode,
      preferredSort: sortBy,
      lastSearches: [] // å¯ä»¥å®ç°æœç´¢å†å²
    };
  }, [viewMode, sortBy]);
  
  // âœ… æ€§èƒ½ç›‘æ§
  const renderCount = useRef(0);
  useEffect(() => {
    renderCount.current += 1;
    console.log(`ğŸ”„ ç»„ä»¶æ¸²æŸ“æ¬¡æ•°: ${renderCount.current}`);
  });
  
  const performanceMetrics = useMemo(() => {
    return {
      totalItems: items.length,
      filteredItems: filteredAndSortedItems.length,
      visibleItems: visibleItemsData.length,
      renderCount: renderCount.current,
      lastUpdate: Date.now()
    };
  }, [items.length, filteredAndSortedItems.length, visibleItemsData.length]);
  
  return (
    <div style={{ padding: '20px', border: '2px solid #e74c3c' }}>
      <h3>Hook æ€§èƒ½ä¼˜åŒ–æ¼”ç¤º</h3>
      
      {/* æ§åˆ¶é¢æ¿ */}
      <div style={{ marginBottom: '20px', display: 'flex', gap: '10px', flexWrap: 'wrap' }}>
        <input
          type="text"
          placeholder="æœç´¢é¡¹ç›®..."
          onChange={(e) => debouncedSearch(e.target.value)}
          style={{ padding: '5px' }}
        />
        
        <select
          value={selectedCategory}
          onChange={(e) => setSelectedCategory(e.target.value)}
          style={{ padding: '5px' }}
        >
          <option value="all">æ‰€æœ‰åˆ†ç±»</option>
          {categories.map(cat => (
            <option key={cat} value={cat}>{cat}</option>
          ))}
        </select>
        
        <select
          value={sortBy}
          onChange={(e) => setSortBy(e.target.value)}
          style={{ padding: '5px' }}
        >
          <option value="name">æŒ‰åç§°æ’åº</option>
          <option value="price">æŒ‰ä»·æ ¼æ’åº</option>
          <option value="date">æŒ‰æ—¥æœŸæ’åº</option>
        </select>
        
        <button
          onClick={() => setViewMode(prev => prev === 'grid' ? 'list' : 'grid')}
          style={{ padding: '5px 10px' }}
        >
          {viewMode === 'grid' ? 'åˆ—è¡¨è§†å›¾' : 'ç½‘æ ¼è§†å›¾'}
        </button>
      </div>
      
      {/* è™šæ‹ŸåŒ–åˆ—è¡¨å®¹å™¨ */}
      <div
        style={{
          height: containerHeight,
          overflow: 'auto',
          border: '1px solid #ddd'
        }}
        onScroll={(e) => setScrollTop(e.target.scrollTop)}
      >
        <div style={{ height: filteredAndSortedItems.length * itemHeight, position: 'relative' }}>
          {visibleItemsData.map((item, index) => (
            <OptimizedItemCard
              key={item.id}
              item={item}
              style={{
                position: 'absolute',
                top: (startIndex + index) * itemHeight,
                left: 0,
                right: 0,
                height: itemHeight - 10
              }}
              onSelect={handleItemSelect}
              onFavorite={handleItemFavorite}
              viewMode={viewMode}
            />
          ))}
        </div>
      </div>
      
      {/* æ€§èƒ½æŒ‡æ ‡ */}
      <div style={{ marginTop: '20px', fontSize: '12px', backgroundColor: '#f8f9fa', padding: '10px' }}>
        <h4>æ€§èƒ½æŒ‡æ ‡:</h4>
        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: '10px' }}>
          <div>æ€»é¡¹ç›®: {performanceMetrics.totalItems}</div>
          <div>è¿‡æ»¤å: {performanceMetrics.filteredItems}</div>
          <div>å¯è§é¡¹ç›®: {performanceMetrics.visibleItems}</div>
          <div>æ¸²æŸ“æ¬¡æ•°: {performanceMetrics.renderCount}</div>
        </div>
      </div>
      
      <div style={{ fontSize: '10px', color: '#666', marginTop: '10px' }}>
        <p>âœ… ä½¿ç”¨äº† useMemoã€useCallbackã€è™šæ‹ŸåŒ–ç­‰ä¼˜åŒ–æŠ€æœ¯</p>
        <p>âœ… çŠ¶æ€åˆ†ç¦»é¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“</p>
        <p>âœ… é˜²æŠ–æœç´¢å‡å°‘è®¡ç®—é¢‘ç‡</p>
      </div>
    </div>
  );
}

// ä¼˜åŒ–çš„é¡¹ç›®å¡ç‰‡ç»„ä»¶
const OptimizedItemCard = memo(function ItemCard({ item, style, onSelect, onFavorite, viewMode }) {
  console.log(`ğŸ¨ æ¸²æŸ“é¡¹ç›®å¡ç‰‡: ${item.name}`);
  
  const handleClick = useCallback(() => {
    onSelect(item.id);
  }, [item.id, onSelect]);
  
  const handleFavoriteClick = useCallback((e) => {
    e.stopPropagation();
    onFavorite(item.id);
  }, [item.id, onFavorite]);
  
  return (
    <div
      style={{
        ...style,
        padding: '10px',
        border: '1px solid #eee',
        margin: '5px',
        cursor: 'pointer',
        backgroundColor: '#fff',
        display: viewMode === 'grid' ? 'block' : 'flex',
        alignItems: viewMode === 'list' ? 'center' : 'stretch'
      }}
      onClick={handleClick}
    >
      <div style={{ flex: 1 }}>
        <h4 style={{ margin: 0 }}>{item.name}</h4>
        <p style={{ margin: '5px 0', color: '#666' }}>{item.category}</p>
        <p style={{ margin: 0, fontWeight: 'bold' }}>Â¥{item.price}</p>
      </div>
      
      <button
        onClick={handleFavoriteClick}
        style={{ padding: '5px', marginLeft: '10px' }}
      >
        â¤ï¸
      </button>
    </div>
  );
});
```

## è°ƒè¯•æŠ€å·§

### Hook è°ƒè¯•æœ€ä½³å®è·µ

```javascript
function DebuggableComponent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  
  // ä½¿ç”¨ useDebugValue æä¾›è°ƒè¯•ä¿¡æ¯
  useDebugValue(`count: ${count}, name: ${name}`);
  
  // ä½¿ç”¨è‡ªå®šä¹‰ Hook å°è£…è°ƒè¯•é€»è¾‘
  useTraceUpdate({ count, name });
  
  return <div>{count} - {name}</div>;
}

// è‡ªå®šä¹‰è°ƒè¯• Hook
function useTraceUpdate(props) {
  const prev = useRef(props);
  
  useEffect(() => {
    const changedProps = Object.entries(props).reduce((ps, [k, v]) => {
      if (prev.current[k] !== v) {
        ps[k] = [prev.current[k], v];
      }
      return ps;
    }, {});
    
    if (Object.keys(changedProps).length > 0) {
      console.log('Changed props:', changedProps);
    }
    
    prev.current = props;
  });
}
```

### æ¡ˆä¾‹ 11ï¼šHook è°ƒè¯•å·¥å…·é›†

```javascript
// å®Œæ•´çš„ Hook è°ƒè¯•å·¥å…·é›†
function useDebugger(componentName, props) {
  const renderCount = useRef(0);
  const prevProps = useRef(props);
  const startTime = useRef(Date.now());
  
  // æ¸²æŸ“è®¡æ•°
  renderCount.current += 1;
  
  // Props å˜åŒ–æ£€æµ‹
  const changedProps = useMemo(() => {
    const changes = {};
    Object.keys(props).forEach(key => {
      if (prevProps.current[key] !== props[key]) {
        changes[key] = {
          from: prevProps.current[key],
          to: props[key]
        };
      }
    });
    prevProps.current = props;
    return changes;
  }, [props]);
  
  // æ€§èƒ½ç›‘æ§
  useEffect(() => {
    const renderTime = Date.now() - startTime.current;
    console.log(`â±ï¸ ${componentName} æ¸²æŸ“è€—æ—¶: ${renderTime}ms`);
    startTime.current = Date.now();
  });
  
  // Hook ä½¿ç”¨ç»Ÿè®¡
  const [hookStats, setHookStats] = useState({ useEffect: 0, useState: 0, useMemo: 0 });
  
  useEffect(() => {
    setHookStats(prev => ({ ...prev, useEffect: prev.useEffect + 1 }));
  });
  
  // è°ƒè¯•ä¿¡æ¯è¾“å‡º
  useDebugValue({
    renderCount: renderCount.current,
    changedProps: Object.keys(changedProps),
    hookStats
  });
  
  return {
    renderCount: renderCount.current,
    changedProps,
    hookStats,
    log: (message, data) => {
      console.group(`ğŸ› ${componentName} - æ¸²æŸ“ #${renderCount.current}`);
      console.log(message, data);
      if (Object.keys(changedProps).length > 0) {
        console.log('Props å˜åŒ–:', changedProps);
      }
      console.groupEnd();
    }
  };
}

// Hook æ€§èƒ½åˆ†æå™¨
function usePerformanceProfiler(name) {
  const mountTime = useRef(Date.now());
  const lastRenderTime = useRef(Date.now());
  const renderTimes = useRef([]);
  
  useEffect(() => {
    const now = Date.now();
    const renderDuration = now - lastRenderTime.current;
    renderTimes.current.push(renderDuration);
    lastRenderTime.current = now;
    
    // ä¿ç•™æœ€è¿‘20æ¬¡æ¸²æŸ“æ—¶é—´
    if (renderTimes.current.length > 20) {
      renderTimes.current.shift();
    }
  });
  
  const getProfileData = useCallback(() => {
    const times = renderTimes.current;
    const avgRenderTime = times.reduce((a, b) => a + b, 0) / times.length;
    const maxRenderTime = Math.max(...times);
    const minRenderTime = Math.min(...times);
    
    return {
      name,
      mountTime: mountTime.current,
      totalLifetime: Date.now() - mountTime.current,
      renderCount: times.length,
      avgRenderTime: avgRenderTime.toFixed(2),
      maxRenderTime,
      minRenderTime
    };
  }, [name]);
  
  return { getProfileData };
}

// è°ƒè¯•æ¼”ç¤ºç»„ä»¶
function DebuggingDemo({ items = [], filter = '' }) {
  const debugger = useDebugger('DebuggingDemo', { items, filter });
  const profiler = usePerformanceProfiler('DebuggingDemo');
  
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');
  
  const filteredItems = useMemo(() => {
    debugger.log('ğŸ” è®¡ç®—è¿‡æ»¤é¡¹ç›®', { itemsLength: items.length, filter });
    return items.filter(item => item.includes(filter));
  }, [items, filter, debugger]);
  
  const expensiveCalculation = useMemo(() => {
    debugger.log('ğŸ§® æ‰§è¡Œæ˜‚è´µè®¡ç®—', { count });
    // æ¨¡æ‹Ÿæ˜‚è´µè®¡ç®—
    let result = 0;
    for (let i = 0; i < count * 1000; i++) {
      result += Math.random();
    }
    return result;
  }, [count, debugger]);
  
  const handleIncrement = useCallback(() => {
    debugger.log('ğŸ–±ï¸ å¤„ç†ç‚¹å‡»äº‹ä»¶');
    setCount(prev => prev + 1);
  }, [debugger]);
  
  useEffect(() => {
    debugger.log('ğŸ¯ useEffect æ‰§è¡Œ', { count, text });
  }, [count, text, debugger]);
  
  // æ˜¾ç¤ºæ€§èƒ½æ•°æ®
  const showPerformanceData = () => {
    const data = profiler.getProfileData();
    console.table(data);
    alert(`æ€§èƒ½æ•°æ®å·²è¾“å‡ºåˆ°æ§åˆ¶å°\nå¹³å‡æ¸²æŸ“æ—¶é—´: ${data.avgRenderTime}ms`);
  };
  
  return (
    <div style={{ padding: '20px', border: '2px solid #f39c12' }}>
      <h3>Hook è°ƒè¯•å·¥å…·æ¼”ç¤º</h3>
      
      <div style={{ marginBottom: '15px' }}>
        <p>æ¸²æŸ“æ¬¡æ•°: <strong>{debugger.renderCount}</strong></p>
        <p>è®¡æ•°: {count}</p>
        <p>è¿‡æ»¤åé¡¹ç›®æ•°: {filteredItems.length}</p>
        <p>è®¡ç®—ç»“æœ: {expensiveCalculation.toFixed(2)}</p>
      </div>
      
      <div style={{ marginBottom: '15px' }}>
        <input
          type="text"
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="è¾“å…¥æ–‡æœ¬..."
          style={{ padding: '5px', marginRight: '10px' }}
        />
        
        <button onClick={handleIncrement} style={{ padding: '5px 10px' }}>
          å¢åŠ è®¡æ•°
        </button>
        
        <button onClick={showPerformanceData} style={{ padding: '5px 10px', marginLeft: '10px' }}>
          æŸ¥çœ‹æ€§èƒ½æ•°æ®
        </button>
      </div>
      
      <div style={{ fontSize: '12px', color: '#666' }}>
        <p>ğŸ› è°ƒè¯•ä¿¡æ¯å·²è¾“å‡ºåˆ°æ§åˆ¶å°</p>
        <p>ğŸ” ä½¿ç”¨ React DevTools æŸ¥çœ‹æ›´å¤šè¯¦ç»†ä¿¡æ¯</p>
        <p>âš¡ å°è¯•ä¿®æ”¹ props è§‚å¯Ÿå˜åŒ–æ£€æµ‹</p>
      </div>
      
      {/* æ˜¾ç¤ºå˜åŒ–çš„ Props */}
      {Object.keys(debugger.changedProps).length > 0 && (
        <div style={{ backgroundColor: '#fff3cd', padding: '10px', marginTop: '10px' }}>
          <h4>Props å˜åŒ–:</h4>
          <pre style={{ fontSize: '12px' }}>
            {JSON.stringify(debugger.changedProps, null, 2)}
          </pre>
        </div>
      )}
    </div>
  );
}

// ä¸»æ¼”ç¤ºç»„ä»¶
function HookFunctionComponentsDemo() {
  const [testItems, setTestItems] = useState(['è‹¹æœ', 'é¦™è•‰', 'æ©™å­', 'è‘¡è„']);
  const [filter, setFilter] = useState('');
  
  return (
    <div>
      <h2>Hook ä¸å‡½æ•°ç»„ä»¶å®Œæ•´æ¼”ç¤º</h2>
      
      <div style={{ marginBottom: '20px' }}>
        <input
          type="text"
          value={filter}
          onChange={(e) => setFilter(e.target.value)}
          placeholder="è¿‡æ»¤é¡¹ç›®..."
          style={{ padding: '5px', marginRight: '10px' }}
        />
        
        <button onClick={() => setTestItems([...testItems, `æ–°é¡¹ç›®${Date.now()}`])}>
          æ·»åŠ é¡¹ç›®
        </button>
      </div>
      
      <DebuggingDemo items={testItems} filter={filter} />
    </div>
  );
}
```

## React Hook vs Vue 3 è®¾è®¡ç†å¿µå¯¹æ¯”

| ç‰¹æ€§ | React Hook | Vue 3 Composition API |
|------|------------|------------------------|
| **çŠ¶æ€ç®¡ç†** | ä¸å¯å˜çŠ¶æ€ï¼Œé€šè¿‡ setter æ›´æ–° | å“åº”å¼å¼•ç”¨ï¼Œç›´æ¥ä¿®æ”¹ |
| **ä¾èµ–ç®¡ç†** | æ‰‹åŠ¨æŒ‡å®šä¾èµ–æ•°ç»„ | è‡ªåŠ¨ä¾èµ–è¿½è¸ª |
| **å‰¯ä½œç”¨** | useEffect æ˜¾å¼å£°æ˜ | watch/watchEffect è‡ªåŠ¨è¿½è¸ª |
| **ç»„åˆæ–¹å¼** | Hook é“¾è¡¨é¡ºåºæ•æ„Ÿ | ç»„åˆå¼å‡½æ•°çµæ´»ç»„åˆ |
| **è°ƒè¯•ä½“éªŒ** | éœ€è¦ ESLint è§„åˆ™è¾…åŠ© | TypeScript åŸç”Ÿæ”¯æŒæ›´å¥½ |
| **å­¦ä¹ æ›²çº¿** | éœ€è¦ç†è§£é—­åŒ…å’Œä¾èµ– | æ›´æ¥è¿‘ä¼ ç»Ÿç¼–ç¨‹æ¨¡å¼ |
| **æ€§èƒ½ä¼˜åŒ–** | æ‰‹åŠ¨ä¼˜åŒ–ï¼ˆuseMemo/useCallbackï¼‰ | è‡ªåŠ¨ä¼˜åŒ–ï¼ˆå“åº”å¼ç³»ç»Ÿï¼‰ |

## æ€»ç»“

Hook ä¸å‡½æ•°ç»„ä»¶çš„ç»“åˆåˆ›é€ äº†ç°ä»£ React å¼€å‘çš„æ ¸å¿ƒæ¨¡å¼ã€‚é€šè¿‡æœ¬ç« çš„æ·±å…¥åˆ†æï¼Œæˆ‘ä»¬äº†è§£åˆ°ï¼š

### æ ¸å¿ƒä¼˜åŠ¿
1. **é€»è¾‘å¤ç”¨**ï¼šè‡ªå®šä¹‰ Hook å®ç°è·¨ç»„ä»¶çš„é€»è¾‘å…±äº«
2. **å…³æ³¨ç‚¹åˆ†ç¦»**ï¼šç›¸å…³é€»è¾‘èšåˆï¼Œæé«˜ä»£ç å¯ç»´æŠ¤æ€§
3. **å‡½æ•°å¼ç¼–ç¨‹**ï¼šæ‹¥æŠ±ä¸å¯å˜çŠ¶æ€å’Œçº¯å‡½æ•°ç†å¿µ
4. **æ¸è¿›å¼å¢å¼º**ï¼šå¯ä»¥é€æ­¥è¿ç§»ç±»ç»„ä»¶åˆ°å‡½æ•°ç»„ä»¶

### è®¾è®¡ç†å¿µ
1. **æ˜¾å¼ä¾èµ–**ï¼šé€šè¿‡ä¾èµ–æ•°ç»„æ˜ç¡®å£°æ˜æ•°æ®æµ
2. **å•ä¸€èŒè´£**ï¼šæ¯ä¸ª Hook ä¸“æ³¨ç‰¹å®šåŠŸèƒ½
3. **ç»„åˆä¼˜äºç»§æ‰¿**ï¼šé€šè¿‡ Hook ç»„åˆå®ç°å¤æ‚åŠŸèƒ½
4. **å¼€å‘æ—¶æ£€æŸ¥**ï¼šä¸¥æ ¼çš„è§„åˆ™ç¡®ä¿æ­£ç¡®ä½¿ç”¨

### æ€§èƒ½ç­–ç•¥
1. **ç²¾ç¡®ä¼˜åŒ–**ï¼šuseMemo å’Œ useCallback ç²¾ç¡®æ§åˆ¶é‡è®¡ç®—
2. **çŠ¶æ€åˆ†ç¦»**ï¼šé¿å…å¤§å¯¹è±¡çŠ¶æ€å¯¼è‡´çš„ä¸å¿…è¦æ¸²æŸ“
3. **è™šæ‹ŸåŒ–**ï¼šå¤„ç†å¤§åˆ—è¡¨çš„é«˜æ•ˆæ¸²æŸ“
4. **è°ƒè¯•å·¥å…·**ï¼šå®Œå–„çš„è°ƒè¯•å’Œæ€§èƒ½åˆ†æå·¥å…·

### ä¸ Vue 3 å¯¹æ¯”
- **React**: æ˜¾å¼ã€å¯é¢„æµ‹ï¼Œéœ€è¦å¼€å‘è€…æ›´å¤šæ§åˆ¶
- **Vue 3**: è‡ªåŠ¨ã€ä¾¿æ·ï¼Œæ¡†æ¶æ‰¿æ‹…æ›´å¤šä¼˜åŒ–è´£ä»»

ç†è§£è¿™äº›æœºåˆ¶æœ‰åŠ©äºæˆ‘ä»¬æ›´å¥½åœ°è®¾è®¡å’Œä¼˜åŒ– React åº”ç”¨ã€‚